// Generated by Haxe 4.0.5
module.exports =
/******/ (function(modules, runtime) { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	__webpack_require__.ab = __dirname + "/";
/******/
/******/ 	// the startup function
/******/ 	function startup() {
/******/ 		// Load entry module and return exports
/******/ 		return __webpack_require__(475);
/******/ 	};
/******/
/******/ 	// run startup
/******/ 	return startup();
/******/ })
/************************************************************************/
/******/ ({

/***/ 87:
/***/ (function(module) {

module.exports = require("os");

/***/ }),

/***/ 129:
/***/ (function(module) {

module.exports = require("child_process");

/***/ }),

/***/ 431:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = __importStar(__webpack_require__(87));
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return (s || '')
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return (s || '')
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 470:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = __webpack_require__(431);
const os = __importStar(__webpack_require__(87));
const path = __importStar(__webpack_require__(622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable
 */
function exportVariable(name, val) {
    process.env[name] = val;
    command_1.issueCommand('set-env', { name }, val);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    command_1.issueCommand('add-path', {}, inputPath);
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.  The value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store
 */
function setOutput(name, value) {
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message
 */
function error(message) {
    command_1.issue('error', message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message
 */
function warning(message) {
    command_1.issue('warning', message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store
 */
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 475:
/***/ (function(__unusedmodule, __unusedexports, __webpack_require__) {

// Generated by Haxe 4.0.5
(function ($global) { "use strict";
class Command {
	static runInDir(dir,cmd,args) {
		var cmd1 = cmd;
		var args1 = args;
		return Command.runCallbackInDir(dir,function() {
			return Command.run(cmd1,args1);
		});
	}
	static runCallbackInDir(dir,func) {
		var oldCwd = process.cwd();
		Command.cd(dir);
		var result = func();
		Command.cd(oldCwd);
		return result;
	}
	static cd(dir) {
		process.stdout.write(Std.string("cd " + dir));
		process.stdout.write("\n");
		if(!Command.dryRun) {
			process.chdir(dir);
		}
	}
	static runUntilFailure(methods) {
		var _g = 0;
		while(_g < methods.length) if(methods[_g++]() != 0) {
			return 1;
		}
		return 0;
	}
	static runAll(methods) {
		var result = 0;
		var _g = 0;
		while(_g < methods.length) if(methods[_g++]() != 0) {
			result = 1;
		}
		return result;
	}
	static runAllNamed(methods) {
		var result = 0;
		var _g = 0;
		while(_g < methods.length) {
			var method = methods[_g];
			++_g;
			if(!method.active) {
				continue;
			}
			actions_Core.startGroup(method.name);
			if(method.run() != 0) {
				result = 1;
			}
			actions_Core.endGroup();
		}
		return result;
	}
	static run(cmd,args) {
		var v = args == null ? "" : args.join(" ");
		process.stdout.write(Std.string("> " + cmd + " " + v));
		process.stdout.write("\n");
		if(Command.dryRun) {
			return 0;
		}
		if(args == null) {
			return js_node_ChildProcess.spawnSync(cmd,{ shell : true, stdio : "inherit"}).status;
		} else {
			return js_node_ChildProcess.spawnSync(cmd,args,{ stdio : "inherit"}).status;
		}
	}
	static putEnv(s,v) {
		process.stdout.write(Std.string("Sys.putEnv(\"" + s + "\", \"" + v + "\")"));
		process.stdout.write("\n");
		if(!Command.dryRun) {
			process.env[s] = v;
		}
	}
}
Command.__name__ = true;
class Flixel {
	static buildProjects(target,args) {
		return Haxelib.run(["flixel-tools","bp",target].concat(args).concat(["-Dno-deprecation-warnings"]));
	}
}
Flixel.__name__ = true;
class Haxelib {
	static run(args) {
		return Command.run("haxelib",["run"].concat(args));
	}
	static install(lib,version) {
		var args = ["install",lib];
		if(version != null) {
			args.push(version);
		}
		args.push("--quiet");
		return Command.run("haxelib",args);
	}
	static git(user,lib,branch,path) {
		var args = ["git",lib,"https://github.com/" + user + "/" + lib];
		if(branch != null) {
			args.push(branch);
		}
		if(path != null) {
			args.push(path);
		}
		args.push("--quiet");
		return Command.run("haxelib",args);
	}
}
Haxelib.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		var x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
}
HxOverrides.__name__ = true;
class haxe_io_Path {
	static join(paths) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < paths.length) {
			var v = paths[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return "";
		}
		var path = _g[0];
		var _g2 = 1;
		var _g11 = _g.length;
		while(_g2 < _g11) {
			path = haxe_io_Path.addTrailingSlash(path);
			path += _g[_g2++];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		var slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		var target = [];
		var _g = 0;
		var _g1 = path.split(slash);
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		var acc_b = "";
		var colon = false;
		var slashes = false;
		var _g2_offset = 0;
		var _g2_s = target.join(slash);
		while(_g2_offset < _g2_s.length) {
			var s = _g2_s;
			var index = _g2_offset++;
			var c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			var c1 = c;
			if(c1 >= 65536) {
				++_g2_offset;
			}
			var c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					var i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				var i1 = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i1);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		var c1 = path.lastIndexOf("/");
		var c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class Main {
	static main() {
		var haxeVersion = actions_Core.getInput("haxe-version");
		var flixelVersions = actions_Core.getInput("flixel-versions");
		var target = actions_Core.getInput("target");
		var runTests = actions_Core.getInput("run-tests") == "true";
		if(runTests) {
			if(target == "hl" && StringTools.startsWith(haxeVersion,"3")) {
				return;
			}
			if(target == "html5" && haxeVersion == "nightly") {
				return;
			}
		}
		actions_Core.startGroup("Installing Haxe Dependencies");
		var haxeVersion1 = haxeVersion;
		var flixelVersions1 = flixelVersions;
		var target1 = target;
		if(Command.runUntilFailure([function() {
			return Main.setupLix(haxeVersion1);
		},function() {
			return Command.run("sudo apt install neko");
		},function() {
			return Main.installHaxelibs(flixelVersions1);
		},function() {
			return Main.installHxcpp(target1);
		}]) != 0) {
			process.exit(1);
		}
		actions_Core.exportVariable("HAXELIB_REPO",Main.HaxelibRepo);
		actions_Core.endGroup();
		actions_Core.startGroup("Listing Dependencies");
		Command.run("lix -v");
		Command.run("haxe -version");
		Command.run("neko -version");
		Command.run("haxelib version");
		Command.run("haxelib config");
		Command.run("haxelib list");
		actions_Core.endGroup();
		if(runTests) {
			actions_Core.startGroup("Test Preparation");
			Command.cd(haxe_io_Path.join([Main.HaxelibRepo,"flixel/git/tests"]));
			Command.putEnv("HXCPP_SILENT","1");
			Command.putEnv("HXCPP_COMPILE_CACHE",process.env["HOME"] + "/hxcpp_cache");
			Command.putEnv("HXCPP_CACHE_MB","5000");
			actions_Core.endGroup();
			var code = Command.runAllNamed(Tests.make(target));
			process.exit(code);
		}
	}
	static setupLix(haxeVersion) {
		js_node_ChildProcess.spawnSync("lix scope",{ shell : true, stdio : "inherit"});
		var path = haxe_io_Path.join([process.env["HOME"],"haxe/.haxerc"]);
		if(!sys_FileSystem.exists(path)) {
			return 1;
		}
		js_node_Fs.writeFileSync(path,"{\"version\": \"stable\", \"resolveLibs\": \"haxelib\"}");
		return Command.run("lix install haxe " + haxeVersion + " --global");
	}
	static installHaxelibs(flixelVersions) {
		var libs = [function() {
			return Haxelib.install("munit");
		},function() {
			return Haxelib.install("hamcrest");
		},function() {
			return Haxelib.install("systools");
		},function() {
			return Haxelib.install("task");
		},function() {
			return Haxelib.install("poly2trihx");
		},function() {
			return Haxelib.install("nape-haxe4");
		},function() {
			return Haxelib.git("HaxeFoundation","hscript");
		},function() {
			return Haxelib.git("larsiusprime","firetongue");
		},function() {
			return Haxelib.git("bendmorris","spinehaxe");
		},function() {
			return Haxelib.git("larsiusprime","steamwrap");
		},function() {
			return Haxelib.install("openfl");
		},function() {
			return Haxelib.install("lime");
		}];
		libs = libs.concat(flixelVersions == "dev" ? [function() {
			return Haxelib.git("HaxeFlixel","flixel");
		},function() {
			return Haxelib.git("HaxeFlixel","flixel-tools");
		},function() {
			return Haxelib.git("HaxeFlixel","flixel-templates");
		},function() {
			return Haxelib.git("HaxeFlixel","flixel-demos");
		},function() {
			return Haxelib.git("HaxeFlixel","flixel-addons");
		},function() {
			return Haxelib.git("HaxeFlixel","flixel-ui");
		}] : [function() {
			return Haxelib.install("flixel");
		},function() {
			return Haxelib.install("flixel-tools");
		},function() {
			return Haxelib.install("flixel-templates");
		},function() {
			return Haxelib.install("flixel-demos");
		},function() {
			return Haxelib.install("flixel-addons");
		},function() {
			return Haxelib.install("flixel-ui");
		}]);
		return Command.runUntilFailure(libs);
	}
	static installHxcpp(target) {
		if(target != "cpp") {
			return 0;
		}
		var hxcppDir = haxe_io_Path.join([Main.HaxelibRepo,"hxcpp/git/"]);
		var dir = hxcppDir + "/tools/run";
		var args = ["compile.hxml"];
		var dir1 = hxcppDir + "/tools/hxcpp";
		var args1 = ["compile.hxml"];
		return Command.runAll([function() {
			return Haxelib.git("HaxeFoundation","hxcpp");
		},function() {
			return Command.runInDir(dir,"haxe",args);
		},function() {
			return Command.runInDir(dir1,"haxe",args1);
		}]);
	}
}
Main.__name__ = true;
Math.__name__ = true;
class OpenFL {
	static build(path,target,define) {
		return OpenFL.run("build",path,target,define);
	}
	static run(operation,path,target,define) {
		var args = ["openfl",operation,path,target];
		if(define != null) {
			args.push("-D" + define);
		}
		return Haxelib.run(args);
	}
}
OpenFL.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static startsWith(s,start) {
		if(s.length >= start.length) {
			return s.lastIndexOf(start,0) == 0;
		} else {
			return false;
		}
	}
}
StringTools.__name__ = true;
class Tests {
	static make(target) {
		var target1 = target;
		var tmp = function() {
			return Tests.runUnitTests(target1);
		};
		var target2 = target;
		var tmp1 = function() {
			return Tests.buildCoverageTests(target2);
		};
		var target3 = target;
		var tmp2 = function() {
			return Tests.buildSwfVersionTests(target3);
		};
		var target4 = target;
		var demos = target == "cpp" ? Tests.ImportantDemos : [];
		var tmp3 = function() {
			return Tests.buildDemos(target4,demos);
		};
		var target5 = target;
		var tmp4 = function() {
			return Tests.buildSnippetsDemos(target5);
		};
		return [{ name : "Running Unit Tests", run : tmp, active : true},{ name : "Building Coverage Tests", run : tmp1, active : true},{ name : "Building SWF Version Tests", run : tmp2, active : target == "flash"},{ name : "Building flixel-demos", run : tmp3, active : true},{ name : "Building snippets.haxeflixel.com Demos", run : tmp4, active : target != "cpp"}];
	}
	static runUnitTests(target) {
		var args = ["munit","gen"];
		Command.runCallbackInDir("unit",function() {
			return Haxelib.run(args);
		});
		if(target == "flash" || target == "html5" || target == "hl") {
			process.stdout.write("Building unit tests...\n");
			process.stdout.write("\n");
			return OpenFL.build("unit",target);
		} else {
			process.stdout.write("Running unit tests...\n");
			process.stdout.write("\n");
			return OpenFL.run("test","unit",target,"travis");
		}
	}
	static buildCoverageTests(target) {
		process.stdout.write("\nBuilding coverage tests...\n");
		process.stdout.write("\n");
		var target1 = target;
		var target2 = target;
		return Command.runAll([function() {
			return OpenFL.build("coverage",target1,"coverage1");
		},function() {
			return OpenFL.build("coverage",target2,"coverage2");
		}]);
	}
	static buildDemos(target,demos) {
		process.stdout.write("\nBuilding demos...\n");
		process.stdout.write("\n");
		return Flixel.buildProjects(target,demos);
	}
	static buildSnippetsDemos(target) {
		process.stdout.write("\nBuilding mechanics demos...\n");
		process.stdout.write("\n");
		Command.run("git",["clone","https://github.com/HaxeFlixel/haxeflixel-mechanics"]);
		return Flixel.buildProjects(target,["-dir","haxeflixel-mechanics"]);
	}
	static buildSwfVersionTests(target) {
		process.stdout.write("\nBuilding swf version tests...\n");
		process.stdout.write("\n");
		var target1 = target;
		var target2 = target;
		return Command.runAll([function() {
			return OpenFL.build("swfVersion/11",target1);
		},function() {
			return OpenFL.build("swfVersion/11_2",target2);
		}]);
	}
}
Tests.__name__ = true;
var actions_Core = __webpack_require__(470);
class haxe_io_Bytes {
}
haxe_io_Bytes.__name__ = true;
class js__$Boot_HaxeError extends Error {
	constructor(val) {
		super();
		this.val = val;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,js__$Boot_HaxeError);
		}
	}
}
js__$Boot_HaxeError.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		var t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				var str = "[";
				s += "\t";
				var _g3 = 0;
				var _g11 = o.length;
				while(_g3 < _g11) {
					var i = _g3++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			var tostr;
			try {
				tostr = o.toString;
			} catch( e1 ) {
				var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				var s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			var str1 = "{\n";
			s += "\t";
			var hasp = o.hasOwnProperty != null;
			var k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str1.length != 2) {
				str1 += ", \n";
			}
			str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str1 += "\n" + s + "}";
			return str1;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_ChildProcess = __webpack_require__(129);
var js_node_Fs = __webpack_require__(747);
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _ ) {
			return false;
		}
	}
}
sys_FileSystem.__name__ = true;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
Command.dryRun = false;
Main.HaxelibRepo = haxe_io_Path.join([process.env["HOME"],"haxe/haxelib"]);
Tests.ImportantDemos = ["Mode"];
Main.main();
})({});


/***/ }),

/***/ 622:
/***/ (function(module) {

module.exports = require("path");

/***/ }),

/***/ 747:
/***/ (function(module) {

module.exports = require("fs");

/***/ })

/******/ });